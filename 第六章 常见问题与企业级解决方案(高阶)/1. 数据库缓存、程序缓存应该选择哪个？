数据库缓存、程序缓存应该选择哪个？
	为什么要使用缓存？
		数据库的记录是存储在硬盘上的，硬盘的读写速度和内存比起来差很多，所以能不能将数据库中查询出来的数据保存到内存上呢。这样，再次执行SQL语句时，先到内存中查找是否有缓存的数据，如果找到就不用到硬盘上查找了。如果在内存中没有找到，那么就去硬盘上查找并且将查找结果缓存到内存上，下次再执行这个SQL语句就可以直接从内存中找到数据了。
		这样提高了检索的查询速度。
		用内存缓存数据的办法不错，但首先得有个大内存才行。
		不过也不用担心，服务器主机内存都很大。 
***	缓存内存问题：
		1.并且可以给缓存规定一个过期的时间，每次从缓存中提取数据的时候就延后这个过期时间。如果是很少被用到的数据，他们的过期时间不会被更新，所以到了过期时间的时候，这个数据就被销毁了。
		2.也可以规定缓存占用内存的上限，如果说超过这个上限，就不在缓存数据了。
		3.或者定期扫描缓存，把使用频率很低的数据清理掉，来腾出宝贵的内存空间

*	数据库性能
		MySQL每秒可以处理5000次读取，或者3000次写入
		响应时间通常在10ms以内。但是在1万并发的时候，要保证10ms以内的响应速度，任何数据库都做不到

	内存中缓存的数据应该由Java程序管理，还是由数据库管理？
		数据库缓存
			1.MySQL缓存是KV结构的，Key是执行过的SQL语句，Value是查询的结果
			2.如果执行添加、修改、删除，或者修改表结构，都会造成缓存清空(清空某一张表有关的缓存，并不是所有表)
		数据查询过程
			执行SQL语句，MySQL先查询缓存。命中数据，就从缓存(内存)提取数据；没有命中，就从数据库(硬盘)中查询数据
		数据库缓存注意事项
			MySQL8以前需要先开启，默认是关闭的
			MySQL8以后的版本，Oracle就把查询缓存这个功能去掉了
			1.所有对数据加锁的事务中，不会使用查询缓存
			2.查询语句必须一模一样，才有机会命中缓存
		那么该不该使用数据库的查询缓存呢？
			1.MySQL8.0去除了查询缓存，Oracle官方也不推荐和使用查询缓存
				验证是否真的不支持查询缓存
				(MySQL8.0)
					SHOW VARIABLES LIKE '%query_cache%';
					查询结果 have_query_cache no
				(MySQL5.7)
					SHOW VARIABLES LIKE '%query_cache%';
					查询结果 have_query_cache yes
							query_cache_limit  
							...
							query_cache_type OFF
			2.当MySQL缓存了很多结果的时候，一条更新语句就会让缓存全部作废，这严重的加重了内存管理的负担
		***		MySQL做不到细颗粒度的控制哪张表可以有查询缓存，哪张表可以没有查询缓存。
				如，用户表经常做添加、修改、查询，每次执行添加或修改时，查询缓存都会作废，所以不应该设置查询缓存。 而角色表，很少会有改动，多数用作缓存，所以这样表就可以设置查询缓存。这点MyMQL做不到。

**		程序缓存的优势
			Redis、Memcached这些缓存产品，结合Spring框架，在程序中可以细颗粒度的，设置哪些数据表查询需要缓存，哪些数据表查询不用缓存。
			如关系表A的数据不怎么发生变化，就可以加上查询缓存。关系表B的数据经常发生变动，就不用加了。
			这种细颗粒度的设置，就避免了添加一条记录，让大量缓存作废的情况

*	SpringCache技术(一)
		方法声明加上了@Cacheable注解，该方法执行的时候，Spring先查找缓存，根据命中的情况决定返回缓存，还是查询数据库。
		@Cacheable("Cache1")
		public User get(Long id) {
			return User对象;
		}
		单表查询结果可以缓存，但是表连接查询，不建议缓存结果
			因为表连接的表中不好说那张表是经常修改的，那张表的不经常修改的
*	SpringCache技术(二)
		给方法声明前面加上@CacheEvict，Spring执行完数据库操作后，删除缓存记录
		@CacheEvict(value="Cache1")
		public void delete(Long id){
			//执行删除操作
		}
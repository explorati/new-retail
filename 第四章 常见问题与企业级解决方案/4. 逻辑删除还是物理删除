逻辑删除还是物理删除
	物理删除就是用DELETE、TRUNCATE、DROP语句删除数据
**	物理删除就是把数据从硬盘中删除，可以释放存储空间，缩小数据表的体积，对性能提升有帮助

	物理删除的代价
*		1.由于物理删除是真删除，所以数据恢复起来难度很大
			真删除的恢复手段：
				一.根据binlog日志文件，将误删除的代码去掉，然后清空数据库，在执行binlog中的内容
				二.缓存同步数据库，开启一个缓存数据库，每个一定时间再同步原数据库中的内容(如间隔24小时在同步)
*		2.物理删除会造成主键的不连续，导致分页查询变慢
			需要一条一条找到第1000条记录
			select...from...limit 1000,20;
			为了加快查询时间(主键的索引是按照二叉树去排序的)：
			select...from...where id>1000 and id<1020;

	什么样的数据不适合物理删除？
*		核心业务表的数据不建议做物理删除，只做状态变更。比如订单作废、账号禁用、优惠券作废等等。
**		既不删除数据，又能缩小数据表体积，可以把记录转移到历史表
			可以把逻辑删除的数据从数据表转移到历史表

***	逻辑删除
		原理：改变数据的状态
*		1.逻辑删除就是在数据表添加一个字段(is_deleted)														，用字段值标记该数据已经逻辑删除，查询的时候跳过这些数据  
			例：select...from...where is_deleted=0;
*		2.核心业务数据表，必须要采用逻辑删除

	对数据表进行逻辑删除步骤
**		1.用SQL语句复制表结构
			create table t_user_history like t_user;
		2.再在数据表中加入字段is_deleted 用来标记是否做逻辑删除，t_user_history不需要这个字段


问题：设计了历史表之后，不是还得做数据迁移，数据迁移之后主键不就又断断续续的了么？
	解答：有一种折中方案，看后续文章。主键的确会断断续续，即逻辑删除后，主键值也是不连续的。
	优化办法：采用主键加速索引，再做表连接查询
	如：select t.id, t.val from t_test t join (select id from t_test limit 1000000,100) tmp on t.id = tmp.id
